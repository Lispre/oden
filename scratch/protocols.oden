package protocols

//----------//
// SEMIRING //
//----------//

// Types that support addition and multiplication.
protocol Semiring(a) {
   add : a -> a -> a
   zero : a
   mul : a -> a -> a
   one : a
}

// consider the `+` operator syntactic sugar for Semiring::add

// then this function...
f(x, y) = x + y
// ...translates and infers to:
f : forall a.
    a -> a -> a
    where Semiring(a)
f(x, y) = Semiring::add(x, y)

// Semiring instance for Maybe-wrapped semiring instances.
instance Semiring(Maybe(a)) where Semiring(a) {
  add(m1, m2) = match (m1, m2) {
    (Just(v1), Just(v2)) => Just(Semiring::add(x, y))
    _                    => Nothing
  }
  zero = Just(Semiring::zero)

  add(m1, m2) = match (m1, m2) {
    (Just(v1), Just(v2)) => Just(Semiring::mul(x, y))
    _                    => Nothing
  }

  one = Just(Semiring::one)
}

main() = match (Just 10) + (Just 11) {
  Just(n) => println(n)
  Nothing => println(":/")
}

//--------//
// ERRORS //
//--------//

// Protocol version of `error` type from Go.
protocol Error(e) {
   Error : e -> string
}

protocol HasError(v) {
   Error : v -> e where Error(e) // won't clash
}

printErr : forall e. e -> () where HasError(e)
printErr(err) = println(HasError::Error(err)) // Protocol is always qualified

instance Error(string) {
  Error(s) = s
}

instance HasError(string) {
   Error(s) = s
}

main() = printErr("Shit broke")
